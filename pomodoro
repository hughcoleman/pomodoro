#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# pomodoro
# Copyright (c) 2020 Hugh Coleman
#
# This file is part of hughcoleman/pomodoro, a Pomodoro timer for the command
# line. It is released under the MIT License (see LICENSE.)

import sys
import argparse
import math
import time

import curses

class Pomodoro:
    """ class Pomodoro
    
    A Pomodoro timer, a time management tool that breaks long periods of
    time into "working" and "resting" blocks. """

    CLOCK = [list(l) for l in """
            ....           
        _d^^^^^^^^b_       
     .d''          ``b.    
   .p'                `q.  
  .d'                  `b. 
 .d'                    `b.
 ::                      ::
 ::       HH:MM:SS       ::
 ::                      ::
 `p.                    .q'
  `p.                  .q' 
   `b.      WORK      .d'  
     `q..          ..p'    
        ^q........p^       
            ''''           
""".split("\n") if l.strip()]

    def render(self, screen):
        # compute h, m, s remaining
        m, s = divmod(self.durations[self.activity] - self.clock, 60)
        h, m = divmod(m, 60)

        # calculate percentage of completion
        percentage = self.clock / self.durations[self.activity]

        # the following variables are used, to allow the use of format
        # placeholders in the template.
        #  - y represents the current row being parsed.
        #  - x represents the x-position of the current character.
        for y, row in enumerate(Pomodoro.CLOCK):
            for x, character in enumerate(row):
                # compute the distance and angle (of this character) to the 
                # centre of the circle O(13.5, 7). angle is normalized to the
                # range [0, tau), where 0 is the vertical and increases in a
                # clockwise direction.
                theta = -math.atan2(x - 13.5, y - 7) + math.pi
                d = math.sqrt((x - 13.5)**2 + (y - 7)**2)

                color = curses.color_pair(0) # 242
                if d <= 3.5:
                    # ..then this is the timer
                    color = curses.color_pair(4) # 8
                elif d <= 5:
                    # ...then this is the activity indicator
                    color = curses.color_pair(7) # 221
                elif theta <= (2 * math.pi * percentage):
                    # ...then this is part of the completed portion of the 
                    # circle
                    color = curses.color_pair(6) # 198

                screen.addch(y, x, character, color)

        # force stdout flush
        screen.refresh()

    def tick(self):
        # render the timer
        # self.render()
        self.clock = self.clock + 1
        
        # handle activity switches
        if self.clock >= self.durations[self.activity]:
            # flip current activity
            self.activity = {
                "work": "rest",
                "rest": "work"
            }[self.activity]

            # reset internal clock
            self.clock = 0
        
    def __init__(self, args):
        self.clock = 0

        self.durations = {
            "work": args.work * 60,
            "rest": args.rest * 60
        }
        self.activity = "work"
        
def main(screen):
    parser = argparse.ArgumentParser()

    parser.add_argument("-w", "--work", default=25, type=int,
            help="number of minutes of work")
    parser.add_argument("-r", "--rest", default=5, type=int,
            help="number of minutes of rest")

    args = parser.parse_args()

    # setup curses/screen options
    curses.start_color()
    curses.use_default_colors()
    screen.timeout(1000)

    for i in range(curses.COLORS):
        curses.init_color(i, 1000, 0, 0)
        curses.init_pair(i + 1, i, 0)

    # create Pomodoro timer instance
    timer = Pomodoro(args)
    while True:
        timer.render(screen)
        timer.tick()

        if screen.getch() == ord("q"):
            return
        
    return

if __name__ == "__main__":
    curses.wrapper(main)
