#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# pomodoro
# Copyright (c) 2020 Hugh Coleman
#
# This file is part of hughcoleman/pomodoro, a Pomodoro timer for the command
# line. It is released under the MIT License (see LICENSE.)

import sys
import argparse
import math
import time

class Pomodoro:
    """ class Pomodoro
    
    A Pomodoro timer, a time management tool that breaks long periods of
    time into "working" and "resting" blocks. """

    CLOCK = [list(l) for l in """
            ....
        _d^^^^^^^^b_
     .d''          ``b.
   .p'                `q.
  .d'                  `b.
 .d'                    `b.
 ::                      ::
 ::       %H:%M:%S       ::
 ::                      ::
 `p.                    .q'
  `p.                  .q'
   `b.%A.d'
     `q..          ..p'
        ^q........p^
            ''''
""".split("\n") if l.strip()]

    def render(self):
        # move cursor to 0, 0 
        print("\u001b[0;0H", end="")

        # compute h, m, s remaining
        m, s = divmod(self.durations[self.activity] - self.clock, 60)
        h, m = divmod(m, 60)

        # calculate percentage of completion
        percentage = self.clock / self.durations[self.activity]

        # the following variables are used, to allow the use of format
        # placeholders in the template.
        #  - y represents the current row being parsed.
        #  - x represents the x-position of the current character.
        #  - column represents an index into Pomodoro.CLOCK[y]
        for y, row in enumerate(Pomodoro.CLOCK):
            x = 0
            column = 0
            while column < len(row):
                character = row[column]

                # compute the distance and angle (of this character) to the 
                # centre of the circle O(13.5, 7). angle is normalized to the
                # range [0, tau), where 0 is the vertical and increases in a
                # clockwise direction.
                theta = -math.atan2(x - 13.5, y - 7) + math.pi
                d = math.sqrt((x - 13.5)**2 + (y - 7)**2)

                # handle formats
                if character in ["%", "$"]:
                    # bit hacky, just overwrite the character variable with new
                    # value
                    character = {
                        "H": str(h).zfill(2),
                        "M": str(m).zfill(2),
                        "S": str(s).zfill(2),
                        "A": str(self.activity.upper()).center(16),
                    }[row[column + 1]]
                    
                    column = column + 1
                    x = x + len(character)

                if d <= 4.5:
                    # ..then this is the timer
                    print("\u001b[38;5;8m" + character + "\u001b[0m", end="")
                elif (column == 7) and (y == 11):
                    # ...then this is the activity indicator
                    print("\u001b[38;5;221m" + character + "\u001b[0m", end="")
                elif theta <= (2 * math.pi * percentage):
                    # ...then this is part of the completed portion of the 
                    # circle
                    print("\u001b[38;5;198m" + character + "\u001b[0m", end="")
                else:
                    # ...then this is part of the incomplete portion of the
                    # circle
                    print("\u001b[38;5;242m" + character + "\u001b[0m", end="")

                column = column + 1
                x = x + 1

            print("", end="\n")

        # force stdout flush
        sys.stdout.flush()

    def tick(self):
        # render the timer
        self.render()
        self.clock = self.clock + 1
        
        # handle activity switches
        if self.clock >= self.durations[self.activity]:
            # flip current activity
            self.activity = {
                "work": "rest",
                "rest": "work"
            }[self.activity]

            # reset internal clock
            self.clock = 0
        
    def __init__(self, args):
        self.clock = 0

        self.durations = {
            "work": args.work * 60,
            "rest": args.rest * 60
        }

        self.activity = "work"
        

if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument("-w", "--work", default=25, type=int,
            help="number of minutes of work")
    parser.add_argument("-r", "--rest", default=5, type=int,
            help="number of minutes of rest")

    args = parser.parse_args()

    # create Pomodoro timer instance
    timer = Pomodoro(args)
   
    # clear terminal and reset cursor
    print("\u001b[2J\u001b[0;0H")

    while True:
        try:
            timer.tick()
            time.sleep(1)
        except KeyboardInterrupt:
            # if there's a KeyboardInterrupt, pause the Pomodoro timer. allow
            # the user to resume, or quit.
            action = input("\u001b[1000DPaused. (r)esume/(q)uit? ").lower()

            if (action in ["r", "resume"]):
                pass
            elif (action in ["q", "quit"]):
                sys.exit(0)
            else:
                raise RuntimeError("illegal selection")
